# О размещении и написании кода

Пример структуры модуля:
- `dtos/` - входные и выходные представления (типы) данных модуля (т.е. то что передается в модуль из других модулей и наоброот).
- `entities/` - сущности (типы), которые являются собой специфичные для модуля объекты.
- `events/` - события, которые происходят в модуле.
- `style/` - стили (в т.ч. изображения), структуры ещё нет. Импортируется в корневой `data` файл проекта.
- `commands` (aka контроллер) - список команд, которые использует игрок. Объявленные методы могут обращаться к сервису своего модуля. 
- `constants` - список констант (постоянных значений) модуля
- `index` - корневой файл включения модуля. Содержит только необходимое для запуска. Импортируется в корневой `control` файл проекта.
- `service` - основная логика работы модуля, в т.ч. методы, которые не являются `@private` могут использоваться другими модулями. 
  - Здесь может быть вывод в чат, но ответы желательно оформлять в `commands`, а здесь только логика.
- `settings` - настройки модуля, блоки разделяются по вложенности названия. Импортируется в корневой `settings` файл проекта.
- `remotes` - консольные команды, но скрытые. Пример вызова (внутри игры в чате): `/c remote.call("mt:teams", "registerAll")`

Ключевые моменты:
- Образцы модулей на которые стоит ровнятся - `offers` (обратите внимание, что он частично является инструментом для остальных модулей), `teams`
- Именования в camelCase формате. Для глобальных переменных с большой буквы (стандартно для Lua).
- Все методы должны иметь комментарий о назначении. Переменные - желательно.
- Все выводы в чат за исключением дебага должны использовать локализацию.
- Чтобы не путать обычные сервисы и сервис модуля именовать его как `*ModuleService`.
- Объявление и вызов методов в объектах через двоеточие (стандартно для Lua, позволяет использовать `self` для обращения к методам/свойствам родительского объекта).
- Для выброса ошибок использовать конструкцию ` error({ ConfigService.getKey('?') })`, а ловить с помощью обёртки `pcall()` над методом в котором ожидается ошибка.
- После внесения изменений/добавлений нужно бампнуть версию в `src/info.json` и указать что изменилось в `src/changelog.txt`. Релиз сам опубликуется (настроен CI).
- В целом нужно соблюдать единообразие, чтобы код читался легко и его выполнение было очевидным, ничего лишнего не торчало.

# Как настроить VSCode для разработки мода?

- [Видео о том как это работает (на англ.)](https://www.youtube.com/watch?v=oNfMNFxy2X4)

1. Устанавливаем расширение [`sumneko.lua`](vscode:extension/sumneko.lua) (валидация синтаксиса Lua)
2. Устанавливаем расширение [`justarandomgeek.factoriomod-debug`](vscode:extension/justarandomgeek.factoriomod-debug) (дебаг; автодподсказки для `sumneko.lua`, которые определят глобальные прототипы [как в доке](https://lua-api.factorio.com/latest/index-prototype.html))
3. Справа внизу появится окошко про сохранение идентификатора стим, жмем "Yes", а остальные игнорируем (уже закоммичено)
4. Создаем символьную ссылку на мод в папку модов, так как дебагер работает только с тем что там видит

    ```sh
    Start-Process cmd -ArgumentList ("/k cd {0}" -f (Get-Location).path) -Verb RunAs # Откроет командную строку от имени админа в этой же папке
    mklink /d "C:\Users\%USERNAME%\AppData\Roaming\Factorio\mods\MultiplayerTeams" "%cd%\src" # Создаст символьную ссылку из модов на папку проекта 'src'
    ```

5. Теперь в любой момент можно запустить дебаг режим (F5)
6. Если у вас не нашёлся клиент игры, то нужно использовать кнопку снизу "Select Version Factorio" (или как-то так)
